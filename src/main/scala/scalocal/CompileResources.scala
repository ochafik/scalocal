package scalocal

import collection.JavaConversions._

// scalac CompileResources.scala && scala CompileResources Test && scalac Test.scala Main.scala && scala Main
object CompileResources {
  import java.io._
  def readProperties(file: File) = {
    import java.util.{Properties, Map}
    val p = new Properties
    val in = new FileInputStream(file)
    try { p.load(in) } 
    finally { in.close }
    (p.asInstanceOf[Map[String, String]]: collection.mutable.Map[String, String]).toMap
  }
  
  trait Feedback {
    def errors(msg: String): Unit
    def warnings(msg: String): Unit
    def infos(msg: String): Unit
  }
  def main(args: Array[String]) {
    var hasError = false
    
    val feedback = new Feedback {
      override def errors(msg: String) = {
        hasError = true
        println("Error: " + msg)
      }
      override def warnings(msg: String) = 
        println("Warning: " + msg)
        
      override def infos(msg: String) = 
        println("Info: " + msg)
    }
    
    args.map(new File(_)) match {
      case Array(resourceRoot, outputDir) => 
        compileResources(resourceRoot, outputDir, feedback)
      case _ =>
        feedback.errors("Syntax: resourceRoot outputDir")
    }
    
    if (hasError)
      System.exit(1)
  }
  
  private def getPropertiesFilesByBaseName(roots: Seq[File]): Map[String, Seq[File]] = {
    roots.flatMap(root => listFiles(root, _.getName.endsWith(".properties")).map { 
      case (file, path) =>
        var components = file.getName.split("\\.")
        assert(components.last == "properties")
        components = components.dropRight(1)
        val packageComponents = path ++ components.dropRight(1)
        val simpleClassName = components.last.split("_")(0)
        (
          (packageComponents ++ Seq(simpleClassName)).mkString("."),
          file
        )
    }).groupBy(_._1).map(p => (p._1, p._2.map(_._2)))
  }
  def listFiles(file: File, filter: File => Boolean, pathFromRoot: Seq[String] = Seq(), first: Boolean = true): Seq[(File, Seq[String])] = { 
    if (file.isDirectory) {
      val newPathFromRoot = if (first) pathFromRoot else pathFromRoot ++ Seq(file.getName)
      file.listFiles.flatMap(listFiles(_ , filter, newPathFromRoot, false))
    } else if (file.exists && filter(file))
      Seq((file, pathFromRoot))
    else
      Seq()
  }
   
  def compileResources(
    resourceRoot: File,
    outputDir: File,
    feedback: Feedback
  ): Seq[File] = {
    for ((baseName, files) <- getPropertiesFilesByBaseName(Seq(resourceRoot)).toSeq) yield {
      feedback.infos("Resource '" + baseName + "' : found " + files.size + " files")
      val parseMessages = true//simpleClassName.endsWith("Messages")
    
      compileResource(
        outputDir,
        baseName,
        files,
        parseMessages,
        feedback
      )
    }
  }
  
  private val baseNameRx = """(?:(.*?)\.)?([^.]+)""".r
  
  def compileResource(
    outputDir: File,
    fullClassName: String,
    inputFiles: Seq[File],
    parseMessages: Boolean,
    feedback: Feedback
  ): File = {
    
    val baseNameRx(packageName, simpleClassName) = fullClassName
    val fileProps = inputFiles.map(file => (file, readProperties(file))).toMap
    val referenceFileOpt = fileProps.find(fp => {
      val n = fp._1.getName
      n == fullClassName + ".properties" || 
      n == simpleClassName + ".properties"
    }).map(_._1)
    for (referenceFile <- referenceFileOpt)
      feedback.infos("Reference file for resource '" + fullClassName + "' : '" + referenceFile + "'")
    
    val referenceKeys = referenceFileOpt.map(f => fileProps(f).keys).getOrElse(
      fileProps.flatMap(_._2.keys).toSet
    ).toIndexedSeq.sorted
    
    for ((file, props) <- fileProps) {
      val missingKeys = referenceKeys.filter(key => !props.contains(key))
      if (!missingKeys.isEmpty) {
        feedback.errors(missingKeys.size + " missing keys in file '" + file + "' :")
        missingKeys.foreach(key => println("\t'" + key + "'"))
      }
      val unknownKeys = props.keys.filter(key => !referenceKeys.contains(key))
      if (!unknownKeys.isEmpty) {
        feedback.warnings(unknownKeys.size + " unknown keys in file '" + file + "' :")
        unknownKeys.foreach(key => println("\t'" + key + "'"))
      }
      
    }
    
    outputDir.mkdirs
    val outputFile = new File(outputDir, fullClassName + ".scala")
    val out = new PrintStream(outputFile)
    if (Option(packageName).map(_.trim).getOrElse("") != "")
      out.println("package " + packageName)
    out.println("""
/**
 * This resource singleton was autogenerated based on the contents of the following files :
 * <ul><li>""" + inputFiles.mkString("</li>\n * <li>") + """</li></ul> 
 */
    """)
    out.println("import java.util._")
    out.println("import java.text._")
    out.println("object " + simpleClassName + " {")
    out.println("\tprivate var $resourceBundle: ResourceBundle = _")
    out.println("""
  private var $locale = Locale.getDefault
  private def $loadBundle(loc: Locale) = this synchronized {
    $resourceBundle = ResourceBundle.getBundle(""" + "\"" + fullClassName + "\"" + """, $locale)
  }
  $loadBundle($locale)
  
  def locale = $locale
  def locale_=(loc: Locale) = this synchronized {
    $loadBundle(loc)
    $locale = loc
  }
    """)
    
    def outputExampleJavaDoc(key: String) =
      for (f <- referenceFileOpt; msg <- fileProps(f).get(key))
        out.println("\t/** Reference message : \"" + msg + "\" */")
        
    def outputVal(key: String) = {
      outputExampleJavaDoc(key)
      out.println("\tlazy val " + key + " = $resourceBundle.getString(\"" + key + "\")")
      out.println()
    }
      
    if (parseMessages) {
      import java.text._
      for (key <- referenceKeys) {
        val formats = (
          fileProps.flatMap { case (file, props) => 
            for (message <- props.get(key)) yield {
              val fmt = new MessageFormat(message)
              fmt.getFormats.zipWithIndex.map {
                case (argFmt, index) =>
                  (index, argFmt, file)
              }
            }
          }
        ).flatten.groupBy(_._1) // group by index
        val argTypes = for ((index, list) <- formats) yield {
          val types = list.map({ case (_, fmt, file) => 
            (
              fmt match {
                case null =>
                  null
                case f: DecimalFormat if f.isParseIntegerOnly =>
                  "Long"
                case f: DecimalFormat if f.isParseBigDecimal =>
                  "BigDecimal"
                case _: DateFormat =>
                  "java.util.Date"
                case _: MessageFormat =>
                  "String"
                case _: DecimalFormat =>
                  "Double"
                case _ =>
                  "Any"
              },
              file
            )
          }).groupBy(_._1)
          
          val actualTypes = types.filter(_._1 ne null)
          //println("Types for key '" + key + "' = " + types.map(_._1))
          (
            index,
            if (actualTypes.isEmpty)
              "Any"
            else if (actualTypes.size == 1)
              actualTypes.head._1
            else {
              feedback.errors("parameter " + index + " of message '" + key + "' has inconsistent format over the localized messages :")
              for ((_, file) <- actualTypes.flatMap(_._2)) println("\tMessage in file '" + file + "' : \n\t\t'" + fileProps(file)(key) + "'")
              "Any"
            }
          )
        }
        
        if (argTypes.isEmpty)
          outputVal(key)
        else {
          val minIndex = argTypes.keys.min
          if (minIndex > 0)
            feedback.warnings("lowest parameter index in key '" + key + "' is " + minIndex + " (might be an error !)")
          val argCount = argTypes.keys.max + 1
          val args = for (i <- 0 until argCount) yield {
            val name = "arg" + i
            (
              name + ": " + argTypes.getOrElse(i, "Any"),
              name + ".asInstanceOf[AnyRef]"
            )
          }
          out.println("\tprivate lazy val " + key + "$fmt = new MessageFormat($resourceBundle.getString(\"" + key + "\"))")
          outputExampleJavaDoc(key)
          out.println("\tdef " + key + "(" + args.map(_._1).mkString(", ") + ") = " + key + "$fmt.format(Array[AnyRef](" + args.map(_._2).mkString(", ") + "))")
          out.println()
        }
      }
    } else {
      referenceKeys.foreach(outputVal)
    }
    out.println("}")
    out.close
    
    feedback.infos("wrote " + referenceKeys.size + " keys in source file '" + outputFile + "'")
    
    outputFile
  }
}
